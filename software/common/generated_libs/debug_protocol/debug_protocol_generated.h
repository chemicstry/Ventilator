// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_DEBUGPROTOCOL_DEBUGPROTOCOL_H_
#define FLATBUFFERS_GENERATED_DEBUGPROTOCOL_DEBUGPROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

namespace DebugProtocol {

struct GetVarRequest;

struct SetVarRequest;

struct VarRequest;

struct GetVarInfoResponse;

struct GetVarResponse;

struct GetVarCountResponse;

enum class CmdCode : int8_t {
  Mode = 0,
  Peek = 1,
  Poke = 2,
  Console = 3,
  Variable = 4,
  Trace = 5,
  EepromAccess = 6,
  MIN = Mode,
  MAX = EepromAccess
};

inline const CmdCode (&EnumValuesCmdCode())[7] {
  static const CmdCode values[] = {
      CmdCode::Mode,     CmdCode::Peek,  CmdCode::Poke,        CmdCode::Console,
      CmdCode::Variable, CmdCode::Trace, CmdCode::EepromAccess};
  return values;
}

inline const char *const *EnumNamesCmdCode() {
  static const char *const names[] = {"Mode",         "Peek",     "Poke",
                                      "Console",      "Variable", "Trace",
                                      "EepromAccess", nullptr};
  return names;
}

inline const char *EnumNameCmdCode(CmdCode e) {
  if (e < CmdCode::Mode || e > CmdCode::EepromAccess)
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCmdCode()[index];
}

enum class VarSubcmd : int8_t {
  GetInfo = 0,
  Get = 1,
  Set = 2,
  GetCount = 3,
  MIN = GetInfo,
  MAX = GetCount
};

inline const VarSubcmd (&EnumValuesVarSubcmd())[4] {
  static const VarSubcmd values[] = {VarSubcmd::GetInfo, VarSubcmd::Get,
                                     VarSubcmd::Set, VarSubcmd::GetCount};
  return values;
}

inline const char *const *EnumNamesVarSubcmd() {
  static const char *const names[] = {"GetInfo", "Get", "Set", "GetCount",
                                      nullptr};
  return names;
}

inline const char *EnumNameVarSubcmd(VarSubcmd e) {
  if (e < VarSubcmd::GetInfo || e > VarSubcmd::GetCount)
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVarSubcmd()[index];
}

enum class Request : uint8_t {
  NONE = 0,
  GetVarRequest = 1,
  SetVarRequest = 2,
  MIN = NONE,
  MAX = SetVarRequest
};

inline const Request (&EnumValuesRequest())[3] {
  static const Request values[] = {Request::NONE, Request::GetVarRequest,
                                   Request::SetVarRequest};
  return values;
}

inline const char *const *EnumNamesRequest() {
  static const char *const names[] = {"NONE", "GetVarRequest", "SetVarRequest",
                                      nullptr};
  return names;
}

inline const char *EnumNameRequest(Request e) {
  if (e < Request::NONE || e > Request::SetVarRequest)
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRequest()[index];
}

template <typename T> struct RequestTraits {
  static const Request enum_value = Request::NONE;
};

template <> struct RequestTraits<GetVarRequest> {
  static const Request enum_value = Request::GetVarRequest;
};

template <> struct RequestTraits<SetVarRequest> {
  static const Request enum_value = Request::SetVarRequest;
};

bool VerifyRequest(flatbuffers::Verifier &verifier, const void *obj,
                   Request type);
bool VerifyRequestVector(
    flatbuffers::Verifier &verifier,
    const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
    const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) GetVarRequest FLATBUFFERS_FINAL_CLASS {
private:
  uint16_t vid_;

public:
  GetVarRequest() {
    memset(static_cast<void *>(this), 0, sizeof(GetVarRequest));
  }
  GetVarRequest(uint16_t _vid) : vid_(flatbuffers::EndianScalar(_vid)) {}
  uint16_t vid() const { return flatbuffers::EndianScalar(vid_); }
};
FLATBUFFERS_STRUCT_END(GetVarRequest, 2);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) SetVarRequest FLATBUFFERS_FINAL_CLASS {
private:
  uint16_t vid_;
  int16_t padding0__;
  uint32_t value_;

public:
  SetVarRequest() {
    memset(static_cast<void *>(this), 0, sizeof(SetVarRequest));
  }
  SetVarRequest(uint16_t _vid, uint32_t _value)
      : vid_(flatbuffers::EndianScalar(_vid)), padding0__(0),
        value_(flatbuffers::EndianScalar(_value)) {
    (void)padding0__;
  }
  uint16_t vid() const { return flatbuffers::EndianScalar(vid_); }
  uint32_t value() const { return flatbuffers::EndianScalar(value_); }
};
FLATBUFFERS_STRUCT_END(SetVarRequest, 8);

struct VarRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUBCMD = 4,
    VT_REQUEST_TYPE = 6,
    VT_REQUEST = 8
  };
  VarSubcmd subcmd() const {
    return static_cast<VarSubcmd>(GetField<int8_t>(VT_SUBCMD, 0));
  }
  Request request_type() const {
    return static_cast<Request>(GetField<uint8_t>(VT_REQUEST_TYPE, 0));
  }
  const void *request() const { return GetPointer<const void *>(VT_REQUEST); }
  template <typename T> const T *request_as() const;
  const GetVarRequest *request_as_GetVarRequest() const {
    return request_type() == Request::GetVarRequest
               ? static_cast<const GetVarRequest *>(request())
               : nullptr;
  }
  const SetVarRequest *request_as_SetVarRequest() const {
    return request_type() == Request::SetVarRequest
               ? static_cast<const SetVarRequest *>(request())
               : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_SUBCMD) &&
           VerifyField<uint8_t>(verifier, VT_REQUEST_TYPE) &&
           VerifyOffset(verifier, VT_REQUEST) &&
           VerifyRequest(verifier, request(), request_type()) &&
           verifier.EndTable();
  }
};

template <>
inline const GetVarRequest *VarRequest::request_as<GetVarRequest>() const {
  return request_as_GetVarRequest();
}

template <>
inline const SetVarRequest *VarRequest::request_as<SetVarRequest>() const {
  return request_as_SetVarRequest();
}

struct VarRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_subcmd(VarSubcmd subcmd) {
    fbb_.AddElement<int8_t>(VarRequest::VT_SUBCMD, static_cast<int8_t>(subcmd),
                            0);
  }
  void add_request_type(Request request_type) {
    fbb_.AddElement<uint8_t>(VarRequest::VT_REQUEST_TYPE,
                             static_cast<uint8_t>(request_type), 0);
  }
  void add_request(flatbuffers::Offset<void> request) {
    fbb_.AddOffset(VarRequest::VT_REQUEST, request);
  }
  explicit VarRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VarRequestBuilder &operator=(const VarRequestBuilder &);
  flatbuffers::Offset<VarRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VarRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<VarRequest>
CreateVarRequest(flatbuffers::FlatBufferBuilder &_fbb,
                 VarSubcmd subcmd = VarSubcmd::GetInfo,
                 Request request_type = Request::NONE,
                 flatbuffers::Offset<void> request = 0) {
  VarRequestBuilder builder_(_fbb);
  builder_.add_request(request);
  builder_.add_request_type(request_type);
  builder_.add_subcmd(subcmd);
  return builder_.Finish();
}

struct GetVarInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_ACCESS = 6,
    VT_RESERVED = 8,
    VT_NAMELEN = 10,
    VT_FMTLEN = 12,
    VT_HELPLEN = 14,
    VT_UNITLEN = 16,
    VT_NAME = 18,
    VT_FMT = 20,
    VT_HELP = 22,
    VT_UNIT = 24
  };
  int8_t type() const { return GetField<int8_t>(VT_TYPE, 0); }
  int8_t access() const { return GetField<int8_t>(VT_ACCESS, 0); }
  int16_t reserved() const { return GetField<int16_t>(VT_RESERVED, 0); }
  int8_t nameLen() const { return GetField<int8_t>(VT_NAMELEN, 0); }
  int8_t fmtLen() const { return GetField<int8_t>(VT_FMTLEN, 0); }
  int8_t helpLen() const { return GetField<int8_t>(VT_HELPLEN, 0); }
  int8_t unitLen() const { return GetField<int8_t>(VT_UNITLEN, 0); }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *fmt() const {
    return GetPointer<const flatbuffers::String *>(VT_FMT);
  }
  const flatbuffers::String *help() const {
    return GetPointer<const flatbuffers::String *>(VT_HELP);
  }
  const flatbuffers::String *unit() const {
    return GetPointer<const flatbuffers::String *>(VT_UNIT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<int8_t>(verifier, VT_ACCESS) &&
           VerifyField<int16_t>(verifier, VT_RESERVED) &&
           VerifyField<int8_t>(verifier, VT_NAMELEN) &&
           VerifyField<int8_t>(verifier, VT_FMTLEN) &&
           VerifyField<int8_t>(verifier, VT_HELPLEN) &&
           VerifyField<int8_t>(verifier, VT_UNITLEN) &&
           VerifyOffset(verifier, VT_NAME) && verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_FMT) && verifier.VerifyString(fmt()) &&
           VerifyOffset(verifier, VT_HELP) && verifier.VerifyString(help()) &&
           VerifyOffset(verifier, VT_UNIT) && verifier.VerifyString(unit()) &&
           verifier.EndTable();
  }
};

struct GetVarInfoResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int8_t type) {
    fbb_.AddElement<int8_t>(GetVarInfoResponse::VT_TYPE, type, 0);
  }
  void add_access(int8_t access) {
    fbb_.AddElement<int8_t>(GetVarInfoResponse::VT_ACCESS, access, 0);
  }
  void add_reserved(int16_t reserved) {
    fbb_.AddElement<int16_t>(GetVarInfoResponse::VT_RESERVED, reserved, 0);
  }
  void add_nameLen(int8_t nameLen) {
    fbb_.AddElement<int8_t>(GetVarInfoResponse::VT_NAMELEN, nameLen, 0);
  }
  void add_fmtLen(int8_t fmtLen) {
    fbb_.AddElement<int8_t>(GetVarInfoResponse::VT_FMTLEN, fmtLen, 0);
  }
  void add_helpLen(int8_t helpLen) {
    fbb_.AddElement<int8_t>(GetVarInfoResponse::VT_HELPLEN, helpLen, 0);
  }
  void add_unitLen(int8_t unitLen) {
    fbb_.AddElement<int8_t>(GetVarInfoResponse::VT_UNITLEN, unitLen, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(GetVarInfoResponse::VT_NAME, name);
  }
  void add_fmt(flatbuffers::Offset<flatbuffers::String> fmt) {
    fbb_.AddOffset(GetVarInfoResponse::VT_FMT, fmt);
  }
  void add_help(flatbuffers::Offset<flatbuffers::String> help) {
    fbb_.AddOffset(GetVarInfoResponse::VT_HELP, help);
  }
  void add_unit(flatbuffers::Offset<flatbuffers::String> unit) {
    fbb_.AddOffset(GetVarInfoResponse::VT_UNIT, unit);
  }
  explicit GetVarInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetVarInfoResponseBuilder &operator=(const GetVarInfoResponseBuilder &);
  flatbuffers::Offset<GetVarInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetVarInfoResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetVarInfoResponse>
CreateGetVarInfoResponse(flatbuffers::FlatBufferBuilder &_fbb, int8_t type = 0,
                         int8_t access = 0, int16_t reserved = 0,
                         int8_t nameLen = 0, int8_t fmtLen = 0,
                         int8_t helpLen = 0, int8_t unitLen = 0,
                         flatbuffers::Offset<flatbuffers::String> name = 0,
                         flatbuffers::Offset<flatbuffers::String> fmt = 0,
                         flatbuffers::Offset<flatbuffers::String> help = 0,
                         flatbuffers::Offset<flatbuffers::String> unit = 0) {
  GetVarInfoResponseBuilder builder_(_fbb);
  builder_.add_unit(unit);
  builder_.add_help(help);
  builder_.add_fmt(fmt);
  builder_.add_name(name);
  builder_.add_reserved(reserved);
  builder_.add_unitLen(unitLen);
  builder_.add_helpLen(helpLen);
  builder_.add_fmtLen(fmtLen);
  builder_.add_nameLen(nameLen);
  builder_.add_access(access);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GetVarInfoResponse> CreateGetVarInfoResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb, int8_t type = 0, int8_t access = 0,
    int16_t reserved = 0, int8_t nameLen = 0, int8_t fmtLen = 0,
    int8_t helpLen = 0, int8_t unitLen = 0, const char *name = nullptr,
    const char *fmt = nullptr, const char *help = nullptr,
    const char *unit = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto fmt__ = fmt ? _fbb.CreateString(fmt) : 0;
  auto help__ = help ? _fbb.CreateString(help) : 0;
  auto unit__ = unit ? _fbb.CreateString(unit) : 0;
  return DebugProtocol::CreateGetVarInfoResponse(
      _fbb, type, access, reserved, nameLen, fmtLen, helpLen, unitLen, name__,
      fmt__, help__, unit__);
}

struct GetVarResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint32_t value() const { return GetField<uint32_t>(VT_VALUE, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VALUE) && verifier.EndTable();
  }
};

struct GetVarResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint32_t value) {
    fbb_.AddElement<uint32_t>(GetVarResponse::VT_VALUE, value, 0);
  }
  explicit GetVarResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetVarResponseBuilder &operator=(const GetVarResponseBuilder &);
  flatbuffers::Offset<GetVarResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetVarResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetVarResponse>
CreateGetVarResponse(flatbuffers::FlatBufferBuilder &_fbb, uint32_t value = 0) {
  GetVarResponseBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct GetVarCountResponse FLATBUFFERS_FINAL_CLASS
    : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int32_t value() const { return GetField<int32_t>(VT_VALUE, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE) && verifier.EndTable();
  }
};

struct GetVarCountResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(GetVarCountResponse::VT_VALUE, value, 0);
  }
  explicit GetVarCountResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetVarCountResponseBuilder &operator=(const GetVarCountResponseBuilder &);
  flatbuffers::Offset<GetVarCountResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetVarCountResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetVarCountResponse>
CreateGetVarCountResponse(flatbuffers::FlatBufferBuilder &_fbb,
                          int32_t value = 0) {
  GetVarCountResponseBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline bool VerifyRequest(flatbuffers::Verifier &verifier, const void *obj,
                          Request type) {
  switch (type) {
  case Request::NONE: {
    return true;
  }
  case Request::GetVarRequest: {
    return verifier.Verify<GetVarRequest>(static_cast<const uint8_t *>(obj), 0);
  }
  case Request::SetVarRequest: {
    return verifier.Verify<SetVarRequest>(static_cast<const uint8_t *>(obj), 0);
  }
  default:
    return false;
  }
}

inline bool VerifyRequestVector(
    flatbuffers::Verifier &verifier,
    const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
    const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types)
    return !values && !types;
  if (values->size() != types->size())
    return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyRequest(verifier, values->Get(i), types->GetEnum<Request>(i))) {
      return false;
    }
  }
  return true;
}

} // namespace DebugProtocol

#endif // FLATBUFFERS_GENERATED_DEBUGPROTOCOL_DEBUGPROTOCOL_H_
