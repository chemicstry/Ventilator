// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_DEBUGFLATBUF_DEBUGFLATBUF_H_
#define FLATBUFFERS_GENERATED_DEBUGFLATBUF_DEBUGFLATBUF_H_

#include "flatbuffers/flatbuffers.h"

namespace DebugFlatbuf {

struct VarAccessData;

struct Request;

struct GetVarInfo;

struct Int;

struct UInt;

struct Float;

enum class CmdCode : int8_t {
  Mode = 0,
  Peek = 1,
  Poke = 2,
  Console = 3,
  Variable = 4,
  Trace = 5,
  EepromAccess = 6,
  MIN = Mode,
  MAX = EepromAccess
};

inline const CmdCode (&EnumValuesCmdCode())[7] {
  static const CmdCode values[] = {
      CmdCode::Mode,     CmdCode::Peek,  CmdCode::Poke,        CmdCode::Console,
      CmdCode::Variable, CmdCode::Trace, CmdCode::EepromAccess};
  return values;
}

inline const char *const *EnumNamesCmdCode() {
  static const char *const names[] = {"Mode",         "Peek",     "Poke",
                                      "Console",      "Variable", "Trace",
                                      "EepromAccess", nullptr};
  return names;
}

inline const char *EnumNameCmdCode(CmdCode e) {
  if (e < CmdCode::Mode || e > CmdCode::EepromAccess)
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCmdCode()[index];
}

enum class VarSubcmd : int8_t {
  GetInfo = 0,
  Get = 1,
  Set = 2,
  GetCount = 3,
  MIN = GetInfo,
  MAX = GetCount
};

inline const VarSubcmd (&EnumValuesVarSubcmd())[4] {
  static const VarSubcmd values[] = {VarSubcmd::GetInfo, VarSubcmd::Get,
                                     VarSubcmd::Set, VarSubcmd::GetCount};
  return values;
}

inline const char *const *EnumNamesVarSubcmd() {
  static const char *const names[] = {"GetInfo", "Get", "Set", "GetCount",
                                      nullptr};
  return names;
}

inline const char *EnumNameVarSubcmd(VarSubcmd e) {
  if (e < VarSubcmd::GetInfo || e > VarSubcmd::GetCount)
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVarSubcmd()[index];
}

enum class CmdData : uint8_t {
  NONE = 0,
  VarAccessData = 1,
  MIN = NONE,
  MAX = VarAccessData
};

inline const CmdData (&EnumValuesCmdData())[2] {
  static const CmdData values[] = {CmdData::NONE, CmdData::VarAccessData};
  return values;
}

inline const char *const *EnumNamesCmdData() {
  static const char *const names[] = {"NONE", "VarAccessData", nullptr};
  return names;
}

inline const char *EnumNameCmdData(CmdData e) {
  if (e < CmdData::NONE || e > CmdData::VarAccessData)
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCmdData()[index];
}

template <typename T> struct CmdDataTraits {
  static const CmdData enum_value = CmdData::NONE;
};

template <> struct CmdDataTraits<VarAccessData> {
  static const CmdData enum_value = CmdData::VarAccessData;
};

bool VerifyCmdData(flatbuffers::Verifier &verifier, const void *obj,
                   CmdData type);
bool VerifyCmdDataVector(
    flatbuffers::Verifier &verifier,
    const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
    const flatbuffers::Vector<uint8_t> *types);

enum class VarAccess : int8_t {
  ReadOnly = 0,
  ReadWrite = 1,
  MIN = ReadOnly,
  MAX = ReadWrite
};

inline const VarAccess (&EnumValuesVarAccess())[2] {
  static const VarAccess values[] = {VarAccess::ReadOnly, VarAccess::ReadWrite};
  return values;
}

inline const char *const *EnumNamesVarAccess() {
  static const char *const names[] = {"ReadOnly", "ReadWrite", nullptr};
  return names;
}

inline const char *EnumNameVarAccess(VarAccess e) {
  if (e < VarAccess::ReadOnly || e > VarAccess::ReadWrite)
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVarAccess()[index];
}

enum class Val : uint8_t {
  NONE = 0,
  Int = 1,
  UInt = 2,
  Float = 3,
  MIN = NONE,
  MAX = Float
};

inline const Val (&EnumValuesVal())[4] {
  static const Val values[] = {Val::NONE, Val::Int, Val::UInt, Val::Float};
  return values;
}

inline const char *const *EnumNamesVal() {
  static const char *const names[] = {"NONE", "Int", "UInt", "Float", nullptr};
  return names;
}

inline const char *EnumNameVal(Val e) {
  if (e < Val::NONE || e > Val::Float)
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVal()[index];
}

template <typename T> struct ValTraits {
  static const Val enum_value = Val::NONE;
};

template <> struct ValTraits<Int> { static const Val enum_value = Val::Int; };

template <> struct ValTraits<UInt> { static const Val enum_value = Val::UInt; };

template <> struct ValTraits<Float> {
  static const Val enum_value = Val::Float;
};

bool VerifyVal(flatbuffers::Verifier &verifier, const void *obj, Val type);
bool VerifyValVector(
    flatbuffers::Verifier &verifier,
    const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
    const flatbuffers::Vector<uint8_t> *types);

struct VarAccessData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUBCMD = 4,
    VT_VID = 6,
    VT_VAL = 8
  };
  VarSubcmd subcmd() const {
    return static_cast<VarSubcmd>(GetField<int8_t>(VT_SUBCMD, 0));
  }
  uint16_t vid() const { return GetField<uint16_t>(VT_VID, 0); }
  uint32_t val() const { return GetField<uint32_t>(VT_VAL, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_SUBCMD) &&
           VerifyField<uint16_t>(verifier, VT_VID) &&
           VerifyField<uint32_t>(verifier, VT_VAL) && verifier.EndTable();
  }
};

struct VarAccessDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_subcmd(VarSubcmd subcmd) {
    fbb_.AddElement<int8_t>(VarAccessData::VT_SUBCMD,
                            static_cast<int8_t>(subcmd), 0);
  }
  void add_vid(uint16_t vid) {
    fbb_.AddElement<uint16_t>(VarAccessData::VT_VID, vid, 0);
  }
  void add_val(uint32_t val) {
    fbb_.AddElement<uint32_t>(VarAccessData::VT_VAL, val, 0);
  }
  explicit VarAccessDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VarAccessDataBuilder &operator=(const VarAccessDataBuilder &);
  flatbuffers::Offset<VarAccessData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VarAccessData>(end);
    return o;
  }
};

inline flatbuffers::Offset<VarAccessData>
CreateVarAccessData(flatbuffers::FlatBufferBuilder &_fbb,
                    VarSubcmd subcmd = VarSubcmd::GetInfo, uint16_t vid = 0,
                    uint32_t val = 0) {
  VarAccessDataBuilder builder_(_fbb);
  builder_.add_val(val);
  builder_.add_vid(vid);
  builder_.add_subcmd(subcmd);
  return builder_.Finish();
}

struct Request FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CMD = 4,
    VT_CMDDATA_TYPE = 6,
    VT_CMDDATA = 8
  };
  CmdCode cmd() const {
    return static_cast<CmdCode>(GetField<int8_t>(VT_CMD, 0));
  }
  CmdData cmddata_type() const {
    return static_cast<CmdData>(GetField<uint8_t>(VT_CMDDATA_TYPE, 0));
  }
  const void *cmddata() const { return GetPointer<const void *>(VT_CMDDATA); }
  template <typename T> const T *cmddata_as() const;
  const VarAccessData *cmddata_as_VarAccessData() const {
    return cmddata_type() == CmdData::VarAccessData
               ? static_cast<const VarAccessData *>(cmddata())
               : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_CMD) &&
           VerifyField<uint8_t>(verifier, VT_CMDDATA_TYPE) &&
           VerifyOffset(verifier, VT_CMDDATA) &&
           VerifyCmdData(verifier, cmddata(), cmddata_type()) &&
           verifier.EndTable();
  }
};

template <>
inline const VarAccessData *Request::cmddata_as<VarAccessData>() const {
  return cmddata_as_VarAccessData();
}

struct RequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cmd(CmdCode cmd) {
    fbb_.AddElement<int8_t>(Request::VT_CMD, static_cast<int8_t>(cmd), 0);
  }
  void add_cmddata_type(CmdData cmddata_type) {
    fbb_.AddElement<uint8_t>(Request::VT_CMDDATA_TYPE,
                             static_cast<uint8_t>(cmddata_type), 0);
  }
  void add_cmddata(flatbuffers::Offset<void> cmddata) {
    fbb_.AddOffset(Request::VT_CMDDATA, cmddata);
  }
  explicit RequestBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequestBuilder &operator=(const RequestBuilder &);
  flatbuffers::Offset<Request> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Request>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request>
CreateRequest(flatbuffers::FlatBufferBuilder &_fbb, CmdCode cmd = CmdCode::Mode,
              CmdData cmddata_type = CmdData::NONE,
              flatbuffers::Offset<void> cmddata = 0) {
  RequestBuilder builder_(_fbb);
  builder_.add_cmddata(cmddata);
  builder_.add_cmddata_type(cmddata_type);
  builder_.add_cmd(cmd);
  return builder_.Finish();
}

struct GetVarInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCESS = 4,
    VT_NAME = 6,
    VT_FMT = 8,
    VT_HELP = 10,
    VT_UNIT = 12
  };
  int8_t access() const { return GetField<int8_t>(VT_ACCESS, 0); }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *fmt() const {
    return GetPointer<const flatbuffers::String *>(VT_FMT);
  }
  const flatbuffers::String *help() const {
    return GetPointer<const flatbuffers::String *>(VT_HELP);
  }
  const flatbuffers::String *unit() const {
    return GetPointer<const flatbuffers::String *>(VT_UNIT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ACCESS) &&
           VerifyOffset(verifier, VT_NAME) && verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_FMT) && verifier.VerifyString(fmt()) &&
           VerifyOffset(verifier, VT_HELP) && verifier.VerifyString(help()) &&
           VerifyOffset(verifier, VT_UNIT) && verifier.VerifyString(unit()) &&
           verifier.EndTable();
  }
};

struct GetVarInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_access(int8_t access) {
    fbb_.AddElement<int8_t>(GetVarInfo::VT_ACCESS, access, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(GetVarInfo::VT_NAME, name);
  }
  void add_fmt(flatbuffers::Offset<flatbuffers::String> fmt) {
    fbb_.AddOffset(GetVarInfo::VT_FMT, fmt);
  }
  void add_help(flatbuffers::Offset<flatbuffers::String> help) {
    fbb_.AddOffset(GetVarInfo::VT_HELP, help);
  }
  void add_unit(flatbuffers::Offset<flatbuffers::String> unit) {
    fbb_.AddOffset(GetVarInfo::VT_UNIT, unit);
  }
  explicit GetVarInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetVarInfoBuilder &operator=(const GetVarInfoBuilder &);
  flatbuffers::Offset<GetVarInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetVarInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetVarInfo>
CreateGetVarInfo(flatbuffers::FlatBufferBuilder &_fbb, int8_t access = 0,
                 flatbuffers::Offset<flatbuffers::String> name = 0,
                 flatbuffers::Offset<flatbuffers::String> fmt = 0,
                 flatbuffers::Offset<flatbuffers::String> help = 0,
                 flatbuffers::Offset<flatbuffers::String> unit = 0) {
  GetVarInfoBuilder builder_(_fbb);
  builder_.add_unit(unit);
  builder_.add_help(help);
  builder_.add_fmt(fmt);
  builder_.add_name(name);
  builder_.add_access(access);
  return builder_.Finish();
}

inline flatbuffers::Offset<GetVarInfo>
CreateGetVarInfoDirect(flatbuffers::FlatBufferBuilder &_fbb, int8_t access = 0,
                       const char *name = nullptr, const char *fmt = nullptr,
                       const char *help = nullptr, const char *unit = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto fmt__ = fmt ? _fbb.CreateString(fmt) : 0;
  auto help__ = help ? _fbb.CreateString(help) : 0;
  auto unit__ = unit ? _fbb.CreateString(unit) : 0;
  return DebugFlatbuf::CreateGetVarInfo(_fbb, access, name__, fmt__, help__,
                                        unit__);
}

struct Int FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int32_t value() const { return GetField<int32_t>(VT_VALUE, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE) && verifier.EndTable();
  }
};

struct IntBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(Int::VT_VALUE, value, 0);
  }
  explicit IntBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IntBuilder &operator=(const IntBuilder &);
  flatbuffers::Offset<Int> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Int>(end);
    return o;
  }
};

inline flatbuffers::Offset<Int> CreateInt(flatbuffers::FlatBufferBuilder &_fbb,
                                          int32_t value = 0) {
  IntBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct UInt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint32_t value() const { return GetField<uint32_t>(VT_VALUE, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VALUE) && verifier.EndTable();
  }
};

struct UIntBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint32_t value) {
    fbb_.AddElement<uint32_t>(UInt::VT_VALUE, value, 0);
  }
  explicit UIntBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UIntBuilder &operator=(const UIntBuilder &);
  flatbuffers::Offset<UInt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UInt>(end);
    return o;
  }
};

inline flatbuffers::Offset<UInt>
CreateUInt(flatbuffers::FlatBufferBuilder &_fbb, uint32_t value = 0) {
  UIntBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Float FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  float value() const { return GetField<float>(VT_VALUE, 0.0f); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE) && verifier.EndTable();
  }
};

struct FloatBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(Float::VT_VALUE, value, 0.0f);
  }
  explicit FloatBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FloatBuilder &operator=(const FloatBuilder &);
  flatbuffers::Offset<Float> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Float>(end);
    return o;
  }
};

inline flatbuffers::Offset<Float>
CreateFloat(flatbuffers::FlatBufferBuilder &_fbb, float value = 0.0f) {
  FloatBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline bool VerifyCmdData(flatbuffers::Verifier &verifier, const void *obj,
                          CmdData type) {
  switch (type) {
  case CmdData::NONE: {
    return true;
  }
  case CmdData::VarAccessData: {
    auto ptr = reinterpret_cast<const VarAccessData *>(obj);
    return verifier.VerifyTable(ptr);
  }
  default:
    return false;
  }
}

inline bool VerifyCmdDataVector(
    flatbuffers::Verifier &verifier,
    const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
    const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types)
    return !values && !types;
  if (values->size() != types->size())
    return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyCmdData(verifier, values->Get(i), types->GetEnum<CmdData>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyVal(flatbuffers::Verifier &verifier, const void *obj,
                      Val type) {
  switch (type) {
  case Val::NONE: {
    return true;
  }
  case Val::Int: {
    auto ptr = reinterpret_cast<const Int *>(obj);
    return verifier.VerifyTable(ptr);
  }
  case Val::UInt: {
    auto ptr = reinterpret_cast<const UInt *>(obj);
    return verifier.VerifyTable(ptr);
  }
  case Val::Float: {
    auto ptr = reinterpret_cast<const Float *>(obj);
    return verifier.VerifyTable(ptr);
  }
  default:
    return false;
  }
}

inline bool
VerifyValVector(flatbuffers::Verifier &verifier,
                const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
                const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types)
    return !values && !types;
  if (values->size() != types->size())
    return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyVal(verifier, values->Get(i), types->GetEnum<Val>(i))) {
      return false;
    }
  }
  return true;
}

} // namespace DebugFlatbuf

#endif // FLATBUFFERS_GENERATED_DEBUGFLATBUF_DEBUGFLATBUF_H_
