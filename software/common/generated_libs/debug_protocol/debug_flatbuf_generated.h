// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_DEBUGFLATBUF_DEBUGFLATBUF_H_
#define FLATBUFFERS_GENERATED_DEBUGFLATBUF_DEBUGFLATBUF_H_

#include "flatbuffers/flatbuffers.h"

namespace DebugFlatbuf {

struct Int;

struct UInt;

struct Float;

struct VarAccessData;

struct Request;

struct GetVarInfoResponse;

enum class CmdCode : int8_t {
  Mode = 0,
  Peek = 1,
  Poke = 2,
  Console = 3,
  Variable = 4,
  Trace = 5,
  EepromAccess = 6,
  MIN = Mode,
  MAX = EepromAccess
};

inline const CmdCode (&EnumValuesCmdCode())[7] {
  static const CmdCode values[] = {
      CmdCode::Mode,     CmdCode::Peek,  CmdCode::Poke,        CmdCode::Console,
      CmdCode::Variable, CmdCode::Trace, CmdCode::EepromAccess};
  return values;
}

inline const char *const *EnumNamesCmdCode() {
  static const char *const names[] = {"Mode",         "Peek",     "Poke",
                                      "Console",      "Variable", "Trace",
                                      "EepromAccess", nullptr};
  return names;
}

inline const char *EnumNameCmdCode(CmdCode e) {
  if (e < CmdCode::Mode || e > CmdCode::EepromAccess)
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCmdCode()[index];
}

enum class VarSubcmd : int8_t {
  GetInfo = 0,
  Get = 1,
  Set = 2,
  GetCount = 3,
  MIN = GetInfo,
  MAX = GetCount
};

inline const VarSubcmd (&EnumValuesVarSubcmd())[4] {
  static const VarSubcmd values[] = {VarSubcmd::GetInfo, VarSubcmd::Get,
                                     VarSubcmd::Set, VarSubcmd::GetCount};
  return values;
}

inline const char *const *EnumNamesVarSubcmd() {
  static const char *const names[] = {"GetInfo", "Get", "Set", "GetCount",
                                      nullptr};
  return names;
}

inline const char *EnumNameVarSubcmd(VarSubcmd e) {
  if (e < VarSubcmd::GetInfo || e > VarSubcmd::GetCount)
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVarSubcmd()[index];
}

enum class CmdData : uint8_t {
  NONE = 0,
  VarAccessData = 1,
  MIN = NONE,
  MAX = VarAccessData
};

inline const CmdData (&EnumValuesCmdData())[2] {
  static const CmdData values[] = {CmdData::NONE, CmdData::VarAccessData};
  return values;
}

inline const char *const *EnumNamesCmdData() {
  static const char *const names[] = {"NONE", "VarAccessData", nullptr};
  return names;
}

inline const char *EnumNameCmdData(CmdData e) {
  if (e < CmdData::NONE || e > CmdData::VarAccessData)
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCmdData()[index];
}

template <typename T> struct CmdDataTraits {
  static const CmdData enum_value = CmdData::NONE;
};

template <> struct CmdDataTraits<VarAccessData> {
  static const CmdData enum_value = CmdData::VarAccessData;
};

bool VerifyCmdData(flatbuffers::Verifier &verifier, const void *obj,
                   CmdData type);
bool VerifyCmdDataVector(
    flatbuffers::Verifier &verifier,
    const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
    const flatbuffers::Vector<uint8_t> *types);

enum class ErrorCode : int8_t {
  None = 0,
  CrcError = 1,
  UnknownCommand = 2,
  MissingData = 3,
  NoMemory = 4,
  InternalError = 5,
  UnknownVariable = 6,
  InvalidData = 7,
  Timeout = 8,
  MIN = None,
  MAX = Timeout
};

inline const ErrorCode (&EnumValuesErrorCode())[9] {
  static const ErrorCode values[] = {ErrorCode::None,
                                     ErrorCode::CrcError,
                                     ErrorCode::UnknownCommand,
                                     ErrorCode::MissingData,
                                     ErrorCode::NoMemory,
                                     ErrorCode::InternalError,
                                     ErrorCode::UnknownVariable,
                                     ErrorCode::InvalidData,
                                     ErrorCode::Timeout};
  return values;
}

inline const char *const *EnumNamesErrorCode() {
  static const char *const names[] = {
      "None",     "CrcError",      "UnknownCommand",  "MissingData",
      "NoMemory", "InternalError", "UnknownVariable", "InvalidData",
      "Timeout",  nullptr};
  return names;
}

inline const char *EnumNameErrorCode(ErrorCode e) {
  if (e < ErrorCode::None || e > ErrorCode::Timeout)
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesErrorCode()[index];
}

enum class ResponseData : uint8_t {
  NONE = 0,
  Int = 1,
  UInt = 2,
  Float = 3,
  GetVarInfoResponse = 4,
  MIN = NONE,
  MAX = GetVarInfoResponse
};

inline const ResponseData (&EnumValuesResponseData())[5] {
  static const ResponseData values[] = {ResponseData::NONE, ResponseData::Int,
                                        ResponseData::UInt, ResponseData::Float,
                                        ResponseData::GetVarInfoResponse};
  return values;
}

inline const char *const *EnumNamesResponseData() {
  static const char *const names[] = {
      "NONE", "Int", "UInt", "Float", "GetVarInfoResponse", nullptr};
  return names;
}

inline const char *EnumNameResponseData(ResponseData e) {
  if (e < ResponseData::NONE || e > ResponseData::GetVarInfoResponse)
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesResponseData()[index];
}

template <typename T> struct ResponseDataTraits {
  static const ResponseData enum_value = ResponseData::NONE;
};

template <> struct ResponseDataTraits<Int> {
  static const ResponseData enum_value = ResponseData::Int;
};

template <> struct ResponseDataTraits<UInt> {
  static const ResponseData enum_value = ResponseData::UInt;
};

template <> struct ResponseDataTraits<Float> {
  static const ResponseData enum_value = ResponseData::Float;
};

template <> struct ResponseDataTraits<GetVarInfoResponse> {
  static const ResponseData enum_value = ResponseData::GetVarInfoResponse;
};

bool VerifyResponseData(flatbuffers::Verifier &verifier, const void *obj,
                        ResponseData type);
bool VerifyResponseDataVector(
    flatbuffers::Verifier &verifier,
    const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
    const flatbuffers::Vector<uint8_t> *types);

struct Int FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL = 4
  };
  int32_t val() const { return GetField<int32_t>(VT_VAL, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VAL) && verifier.EndTable();
  }
};

struct IntBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_val(int32_t val) { fbb_.AddElement<int32_t>(Int::VT_VAL, val, 0); }
  explicit IntBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IntBuilder &operator=(const IntBuilder &);
  flatbuffers::Offset<Int> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Int>(end);
    return o;
  }
};

inline flatbuffers::Offset<Int> CreateInt(flatbuffers::FlatBufferBuilder &_fbb,
                                          int32_t val = 0) {
  IntBuilder builder_(_fbb);
  builder_.add_val(val);
  return builder_.Finish();
}

struct UInt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL = 4
  };
  uint32_t val() const { return GetField<uint32_t>(VT_VAL, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VAL) && verifier.EndTable();
  }
};

struct UIntBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_val(uint32_t val) {
    fbb_.AddElement<uint32_t>(UInt::VT_VAL, val, 0);
  }
  explicit UIntBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UIntBuilder &operator=(const UIntBuilder &);
  flatbuffers::Offset<UInt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UInt>(end);
    return o;
  }
};

inline flatbuffers::Offset<UInt>
CreateUInt(flatbuffers::FlatBufferBuilder &_fbb, uint32_t val = 0) {
  UIntBuilder builder_(_fbb);
  builder_.add_val(val);
  return builder_.Finish();
}

struct Float FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL = 4
  };
  float val() const { return GetField<float>(VT_VAL, 0.0f); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<float>(verifier, VT_VAL) &&
           verifier.EndTable();
  }
};

struct FloatBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_val(float val) { fbb_.AddElement<float>(Float::VT_VAL, val, 0.0f); }
  explicit FloatBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FloatBuilder &operator=(const FloatBuilder &);
  flatbuffers::Offset<Float> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Float>(end);
    return o;
  }
};

inline flatbuffers::Offset<Float>
CreateFloat(flatbuffers::FlatBufferBuilder &_fbb, float val = 0.0f) {
  FloatBuilder builder_(_fbb);
  builder_.add_val(val);
  return builder_.Finish();
}

struct VarAccessData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUBCMD = 4,
    VT_VID = 6,
    VT_VAL = 8
  };
  VarSubcmd subcmd() const {
    return static_cast<VarSubcmd>(GetField<int8_t>(VT_SUBCMD, 0));
  }
  uint16_t vid() const { return GetField<uint16_t>(VT_VID, 65535); }
  uint32_t val() const { return GetField<uint32_t>(VT_VAL, 4294967295); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_SUBCMD) &&
           VerifyField<uint16_t>(verifier, VT_VID) &&
           VerifyField<uint32_t>(verifier, VT_VAL) && verifier.EndTable();
  }
};

struct VarAccessDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_subcmd(VarSubcmd subcmd) {
    fbb_.AddElement<int8_t>(VarAccessData::VT_SUBCMD,
                            static_cast<int8_t>(subcmd), 0);
  }
  void add_vid(uint16_t vid) {
    fbb_.AddElement<uint16_t>(VarAccessData::VT_VID, vid, 65535);
  }
  void add_val(uint32_t val) {
    fbb_.AddElement<uint32_t>(VarAccessData::VT_VAL, val, 4294967295);
  }
  explicit VarAccessDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VarAccessDataBuilder &operator=(const VarAccessDataBuilder &);
  flatbuffers::Offset<VarAccessData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VarAccessData>(end);
    return o;
  }
};

inline flatbuffers::Offset<VarAccessData>
CreateVarAccessData(flatbuffers::FlatBufferBuilder &_fbb,
                    VarSubcmd subcmd = VarSubcmd::GetInfo, uint16_t vid = 65535,
                    uint32_t val = 4294967295) {
  VarAccessDataBuilder builder_(_fbb);
  builder_.add_val(val);
  builder_.add_vid(vid);
  builder_.add_subcmd(subcmd);
  return builder_.Finish();
}

struct Request FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CMD = 4,
    VT_CMDDATA_TYPE = 6,
    VT_CMDDATA = 8
  };
  CmdCode cmd() const {
    return static_cast<CmdCode>(GetField<int8_t>(VT_CMD, 0));
  }
  CmdData cmddata_type() const {
    return static_cast<CmdData>(GetField<uint8_t>(VT_CMDDATA_TYPE, 0));
  }
  const void *cmddata() const { return GetPointer<const void *>(VT_CMDDATA); }
  template <typename T> const T *cmddata_as() const;
  const VarAccessData *cmddata_as_VarAccessData() const {
    return cmddata_type() == CmdData::VarAccessData
               ? static_cast<const VarAccessData *>(cmddata())
               : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_CMD) &&
           VerifyField<uint8_t>(verifier, VT_CMDDATA_TYPE) &&
           VerifyOffset(verifier, VT_CMDDATA) &&
           VerifyCmdData(verifier, cmddata(), cmddata_type()) &&
           verifier.EndTable();
  }
};

template <>
inline const VarAccessData *Request::cmddata_as<VarAccessData>() const {
  return cmddata_as_VarAccessData();
}

struct RequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cmd(CmdCode cmd) {
    fbb_.AddElement<int8_t>(Request::VT_CMD, static_cast<int8_t>(cmd), 0);
  }
  void add_cmddata_type(CmdData cmddata_type) {
    fbb_.AddElement<uint8_t>(Request::VT_CMDDATA_TYPE,
                             static_cast<uint8_t>(cmddata_type), 0);
  }
  void add_cmddata(flatbuffers::Offset<void> cmddata) {
    fbb_.AddOffset(Request::VT_CMDDATA, cmddata);
  }
  explicit RequestBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequestBuilder &operator=(const RequestBuilder &);
  flatbuffers::Offset<Request> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Request>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request>
CreateRequest(flatbuffers::FlatBufferBuilder &_fbb, CmdCode cmd = CmdCode::Mode,
              CmdData cmddata_type = CmdData::NONE,
              flatbuffers::Offset<void> cmddata = 0) {
  RequestBuilder builder_(_fbb);
  builder_.add_cmddata(cmddata);
  builder_.add_cmddata_type(cmddata_type);
  builder_.add_cmd(cmd);
  return builder_.Finish();
}

struct GetVarInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCESS = 4,
    VT_NAME = 6,
    VT_FMT = 8,
    VT_HELP = 10,
    VT_UNIT = 12
  };
  int8_t access() const { return GetField<int8_t>(VT_ACCESS, 0); }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *fmt() const {
    return GetPointer<const flatbuffers::String *>(VT_FMT);
  }
  const flatbuffers::String *help() const {
    return GetPointer<const flatbuffers::String *>(VT_HELP);
  }
  const flatbuffers::String *unit() const {
    return GetPointer<const flatbuffers::String *>(VT_UNIT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ACCESS) &&
           VerifyOffset(verifier, VT_NAME) && verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_FMT) && verifier.VerifyString(fmt()) &&
           VerifyOffset(verifier, VT_HELP) && verifier.VerifyString(help()) &&
           VerifyOffset(verifier, VT_UNIT) && verifier.VerifyString(unit()) &&
           verifier.EndTable();
  }
};

struct GetVarInfoResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_access(int8_t access) {
    fbb_.AddElement<int8_t>(GetVarInfoResponse::VT_ACCESS, access, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(GetVarInfoResponse::VT_NAME, name);
  }
  void add_fmt(flatbuffers::Offset<flatbuffers::String> fmt) {
    fbb_.AddOffset(GetVarInfoResponse::VT_FMT, fmt);
  }
  void add_help(flatbuffers::Offset<flatbuffers::String> help) {
    fbb_.AddOffset(GetVarInfoResponse::VT_HELP, help);
  }
  void add_unit(flatbuffers::Offset<flatbuffers::String> unit) {
    fbb_.AddOffset(GetVarInfoResponse::VT_UNIT, unit);
  }
  explicit GetVarInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetVarInfoResponseBuilder &operator=(const GetVarInfoResponseBuilder &);
  flatbuffers::Offset<GetVarInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetVarInfoResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetVarInfoResponse>
CreateGetVarInfoResponse(flatbuffers::FlatBufferBuilder &_fbb,
                         int8_t access = 0,
                         flatbuffers::Offset<flatbuffers::String> name = 0,
                         flatbuffers::Offset<flatbuffers::String> fmt = 0,
                         flatbuffers::Offset<flatbuffers::String> help = 0,
                         flatbuffers::Offset<flatbuffers::String> unit = 0) {
  GetVarInfoResponseBuilder builder_(_fbb);
  builder_.add_unit(unit);
  builder_.add_help(help);
  builder_.add_fmt(fmt);
  builder_.add_name(name);
  builder_.add_access(access);
  return builder_.Finish();
}

inline flatbuffers::Offset<GetVarInfoResponse> CreateGetVarInfoResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb, int8_t access = 0,
    const char *name = nullptr, const char *fmt = nullptr,
    const char *help = nullptr, const char *unit = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto fmt__ = fmt ? _fbb.CreateString(fmt) : 0;
  auto help__ = help ? _fbb.CreateString(help) : 0;
  auto unit__ = unit ? _fbb.CreateString(unit) : 0;
  return DebugFlatbuf::CreateGetVarInfoResponse(_fbb, access, name__, fmt__,
                                                help__, unit__);
}

inline bool VerifyCmdData(flatbuffers::Verifier &verifier, const void *obj,
                          CmdData type) {
  switch (type) {
  case CmdData::NONE: {
    return true;
  }
  case CmdData::VarAccessData: {
    auto ptr = reinterpret_cast<const VarAccessData *>(obj);
    return verifier.VerifyTable(ptr);
  }
  default:
    return false;
  }
}

inline bool VerifyCmdDataVector(
    flatbuffers::Verifier &verifier,
    const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
    const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types)
    return !values && !types;
  if (values->size() != types->size())
    return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyCmdData(verifier, values->Get(i), types->GetEnum<CmdData>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyResponseData(flatbuffers::Verifier &verifier, const void *obj,
                               ResponseData type) {
  switch (type) {
  case ResponseData::NONE: {
    return true;
  }
  case ResponseData::Int: {
    auto ptr = reinterpret_cast<const Int *>(obj);
    return verifier.VerifyTable(ptr);
  }
  case ResponseData::UInt: {
    auto ptr = reinterpret_cast<const UInt *>(obj);
    return verifier.VerifyTable(ptr);
  }
  case ResponseData::Float: {
    auto ptr = reinterpret_cast<const Float *>(obj);
    return verifier.VerifyTable(ptr);
  }
  case ResponseData::GetVarInfoResponse: {
    auto ptr = reinterpret_cast<const GetVarInfoResponse *>(obj);
    return verifier.VerifyTable(ptr);
  }
  default:
    return false;
  }
}

inline bool VerifyResponseDataVector(
    flatbuffers::Verifier &verifier,
    const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
    const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types)
    return !values && !types;
  if (values->size() != types->size())
    return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyResponseData(verifier, values->Get(i),
                            types->GetEnum<ResponseData>(i))) {
      return false;
    }
  }
  return true;
}

} // namespace DebugFlatbuf

#endif // FLATBUFFERS_GENERATED_DEBUGFLATBUF_DEBUGFLATBUF_H_
